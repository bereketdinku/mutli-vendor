import * as S from '@effect/schema/Schema';
import { MimeType } from '@uploadthing/mime-types';
import * as Effect from 'effect/Effect';
import * as effect_Cause from 'effect/Cause';
import * as effect_Types from 'effect/Types';
import { ParseError } from '@effect/schema/ParseResult';
import * as Context from 'effect/Context';
import * as Duration from 'effect/Duration';
import * as Schedule from 'effect/Schedule';
import { ReactNode, CSSProperties } from 'react';
import { JSX } from 'solid-js/jsx-runtime';
import { RenderFunction, StyleValue } from 'vue';

declare const ALLOWED_FILE_TYPES: readonly ["image", "video", "audio", "pdf", "text", "blob"];
type AllowedFileType = (typeof ALLOWED_FILE_TYPES)[number];

type JsonValue = string | number | boolean | null | undefined;
type JsonArray = JsonValue[];
type JsonObject = {
    [key: string]: JsonValue | JsonObject | JsonArray;
};
type Json = JsonValue | JsonObject | JsonArray;
type Overwrite<T, U> = Omit<T, keyof U> & U;
type WithRequired<T, K extends keyof T> = T & Required<Pick<T, K>>;
type ErrorMessage<TError extends string> = TError;
type Simplify<TType> = {
    [TKey in keyof TType]: TType[TKey];
} & {};
type MaybePromise<TType> = TType | Promise<TType>;
type Either<TData, TError> = {
    data: TData;
    error: null;
} | {
    data: null;
    error: TError;
};
type ExtendObjectIf<Predicate, ToAdd> = undefined extends Predicate ? {} : ToAdd;
/**
 * A subset of the standard RequestInit properties needed by UploadThing internally.
 * @see RequestInit from lib.dom.d.ts
 */
interface RequestInitEsque {
    /**
     * Sets the request's body.
     */
    body?: FormData | ReadableStream | string | null;
    /**
     * Sets the request's associated headers.
     */
    headers?: [string, string][] | Record<string, string>;
    /**
     * The request's HTTP-style method.
     */
    method?: string;
}
/**
 * A subset of the standard Response properties needed by UploadThing internally.
 * @see Response from lib.dom.d.ts
 */
interface ResponseEsque {
    status: number;
    statusText: string;
    ok: boolean;
    /**
     * @remarks
     * The built-in Response::json() method returns Promise<any>, but
     * that's not as type-safe as unknown. We use unknown because we're
     * more type-safe. You do want more type safety, right? ðŸ˜‰
     */
    json: <T = unknown>() => Promise<T>;
    text: () => Promise<string>;
    blob: () => Promise<Blob>;
    headers: Headers;
    clone: () => ResponseEsque;
}
type MaybeUrl = string | URL;
/**
 * A subset of the standard fetch function type needed by UploadThing internally.
 * @see fetch from lib.dom.d.ts
 */
type FetchEsque = (input: RequestInfo | MaybeUrl, init?: RequestInit | RequestInitEsque) => Promise<ResponseEsque>;
type PowOf2 = 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 512 | 1024;
type SizeUnit = "B" | "KB" | "MB" | "GB";
type FileSize = `${PowOf2}${SizeUnit}`;
type TimeShort = "s" | "m" | "h" | "d";
type TimeLong = "second" | "minute" | "hour" | "day";
type SuggestedNumbers = 2 | 3 | 4 | 5 | 6 | 7 | 10 | 15 | 30 | 60;
type AutoCompleteableNumber = SuggestedNumbers | (number & {});
type Time = number | `1${TimeShort}` | `${AutoCompleteableNumber}${TimeShort}` | `1 ${TimeLong}` | `${AutoCompleteableNumber} ${TimeLong}s`;
declare const ContentDispositionSchema: S.Literal<["inline", "attachment"]>;
type ContentDisposition = S.Schema.Type<typeof ContentDispositionSchema>;
declare const ACLSchema: S.Literal<["public-read", "private"]>;
type ACL = S.Schema.Type<typeof ACLSchema>;
type RouteConfig = {
    maxFileSize: FileSize;
    maxFileCount: number;
    minFileCount: number;
    contentDisposition: ContentDisposition;
    acl?: ACL;
};
type FileRouterInputKey = AllowedFileType | MimeType;
type ExpandedRouteConfig = {
    [key in FileRouterInputKey]?: RouteConfig;
};
type EndpointMetadata = {
    slug: string;
    config: ExpandedRouteConfig;
}[];
type PartialRouteConfig = Partial<Record<FileRouterInputKey, Partial<RouteConfig>>>;
type FileRouterInputConfig = FileRouterInputKey[] | PartialRouteConfig;

declare const InvalidRouteConfigError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "InvalidRouteConfig";
} & Readonly<A>;
declare class InvalidRouteConfigError extends InvalidRouteConfigError_base<{
    reason: string;
}> {
    constructor(type: string, field?: string);
}
declare const UnknownFileTypeError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "UnknownFileType";
} & Readonly<A>;
declare class UnknownFileTypeError extends UnknownFileTypeError_base<{
    reason: string;
}> {
    constructor(fileName: string);
}
declare const InvalidFileTypeError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "InvalidFileType";
} & Readonly<A>;
declare class InvalidFileTypeError extends InvalidFileTypeError_base<{
    reason: string;
}> {
    constructor(fileType: string, fileName: string);
}
declare const InvalidFileSizeError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "InvalidFileSize";
} & Readonly<A>;
declare class InvalidFileSizeError extends InvalidFileSizeError_base<{
    reason: string;
}> {
    constructor(fileSize: string);
}
declare const InvalidURLError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "InvalidURL";
} & Readonly<A>;
declare class InvalidURLError extends InvalidURLError_base<{
    reason: string;
}> {
    constructor(attemptedUrl: string);
}
declare const RetryError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "RetryError";
} & Readonly<A>;
declare class RetryError extends RetryError_base {
}
declare const FetchError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "FetchError";
} & Readonly<A>;
declare class FetchError<T = unknown> extends FetchError_base<{
    readonly input: RequestInfo | URL;
    readonly error: unknown;
    readonly data?: T;
}> {
}

declare function isRouteArray(routeConfig: FileRouterInputConfig): routeConfig is FileRouterInputKey[];
declare function getDefaultSizeForType(fileType: FileRouterInputKey): FileSize;
/**
 * This function takes in the user's input and "upscales" it to a full config
 *
 * Example:
 * ```ts
 * ["image"] => { image: { maxFileSize: "4MB", limit: 1 } }
 * ```
 */
declare const fillInputRouteConfig: (routeConfig: FileRouterInputConfig) => Effect.Effect<ExpandedRouteConfig, InvalidRouteConfigError>;
declare const getTypeFromFileName: (fileName: string, allowedTypes: FileRouterInputKey[]) => Effect.Effect<FileRouterInputKey, UnknownFileTypeError | InvalidFileTypeError>;
declare function generateUploadThingURL(path: `/${string}`): string;
declare const FILESIZE_UNITS: readonly ["B", "KB", "MB", "GB"];
type FileSizeUnit = (typeof FILESIZE_UNITS)[number];
declare const fileSizeToBytes: (fileSize: FileSize) => Effect.Effect<number, InvalidFileSizeError>;
declare const bytesToFileSize: (bytes: number) => string;
declare function safeParseJSON<T>(input: string | ResponseEsque | Request): Promise<T | Error>;
/** typesafe Object.keys */
declare function objectKeys<T extends Record<string, unknown>>(obj: T): (keyof T)[];
/** checks if obj is a valid, non-null object */
declare function isObject(obj: unknown): obj is Record<string, unknown>;
declare function asArray<T>(val: T | T[]): T[];
/**
 * Filters an object's values based on a predicate
 * @example
 * filterObjectValues({ a: "a", b: null }, (v): v is string => v != null)
 * // ^? Record<string, string> { a: "a" }
 */
declare const filterObjectValues: <V, T extends Record<string, V>, D extends V>(obj: T, predicate: (val: V) => val is D) => Record<string, D>;
/** construct content-disposition header */
declare function contentDisposition(contentDisposition: ContentDisposition, fileName: string): string;
declare function semverLite(required: string, toCheck: string): boolean;
declare const getFullApiUrl: (maybeUrl?: string) => Effect.Effect<URL, InvalidURLError>;
declare const resolveMaybeUrlArg: (maybeUrl: string | URL | undefined) => URL;

declare const ERROR_CODES: {
    readonly BAD_REQUEST: 400;
    readonly NOT_FOUND: 404;
    readonly FORBIDDEN: 403;
    readonly INTERNAL_SERVER_ERROR: 500;
    readonly INTERNAL_CLIENT_ERROR: 500;
    readonly TOO_LARGE: 413;
    readonly TOO_SMALL: 400;
    readonly TOO_MANY_FILES: 400;
    readonly KEY_TOO_LONG: 400;
    readonly URL_GENERATION_FAILED: 500;
    readonly UPLOAD_FAILED: 500;
    readonly MISSING_ENV: 500;
    readonly FILE_LIMIT_EXCEEDED: 500;
};
type ErrorCode = keyof typeof ERROR_CODES;
type UploadThingErrorOptions<T> = {
    code: keyof typeof ERROR_CODES;
    message?: string | undefined;
    cause?: unknown;
    data?: T;
};
interface SerializedUploadThingError {
    code: ErrorCode;
    message: string;
    data?: Json;
}
declare const UploadThingError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "UploadThingError";
} & Readonly<A>;
declare class UploadThingError<TShape extends Json = {
    message: string;
}> extends UploadThingError_base<{
    message: string;
}> {
    readonly cause?: unknown;
    readonly code: ErrorCode;
    readonly data: TShape | undefined;
    constructor(initOpts: UploadThingErrorOptions<TShape> | string);
    static toObject(error: UploadThingError): SerializedUploadThingError;
    static serialize(error: UploadThingError): string;
}
declare function getStatusCodeFromError(error: UploadThingError<any>): 400 | 404 | 403 | 500 | 413;
declare const INTERNAL_DO_NOT_USE__fatalClientError: (e: Error) => UploadThingError<{
    message: string;
}>;

type FetchContextService = {
    fetch: FetchEsque;
    baseHeaders: Record<string, string | undefined> & {
        "x-uploadthing-version": string;
        "x-uploadthing-api-key": string | undefined;
        "x-uploadthing-fe-package": string | undefined;
        "x-uploadthing-be-adapter": string | undefined;
    };
};
declare const FetchContext_base: Context.TagClass<FetchContext, "uploadthing/FetchContext", FetchContextService>;
declare class FetchContext extends FetchContext_base {
}
declare const fetchEff: (input: RequestInfo | URL, init?: RequestInit) => Effect.Effect<ResponseEsque, FetchError, FetchContext>;
declare const fetchEffJson: <Schema>(input: RequestInfo | URL, schema: S.Schema<Schema, any>, init?: RequestInit) => Effect.Effect<Schema, FetchError | ParseError, FetchContext>;
declare const parseRequestJson: <Schema>(reqOrRes: Request | ResponseEsque, schema: S.Schema<Schema, any>) => Effect.Effect<Schema, FetchError | ParseError>;
/**
 * Schedule that retries with exponential backoff, up to 1 minute.
 * 10ms * 4^n, where n is the number of retries.
 */
declare const exponentialBackoff: Schedule.Schedule<Duration.DurationInput, unknown, never>;

declare const generateMimeTypes: (fileTypes: string[]) => string[];
declare const generateClientDropzoneAccept: (fileTypes: string[]) => {
    [k: string]: never[];
};
declare function getFilesFromClipboardEvent(event: ClipboardEvent): File[] | undefined;
/**
 * Shared helpers for our premade components that's reusable by multiple frameworks
 */
declare const generatePermittedFileTypes: (config?: ExpandedRouteConfig) => {
    fileTypes: FileRouterInputKey[];
    multiple: boolean;
};
declare const capitalizeStart: (str: string) => string;
declare const INTERNAL_doFormatting: (config?: ExpandedRouteConfig) => string;
declare const allowedContentTextLabelGenerator: (config?: ExpandedRouteConfig) => string;
type AnyRuntime = "react" | "solid" | "svelte" | "vue";
type MinCallbackArg = {
    __runtime: AnyRuntime;
};
type inferRuntime<T extends MinCallbackArg> = T["__runtime"] extends "react" ? "react" : T["__runtime"] extends "solid" ? "solid" : T["__runtime"] extends "svelte" ? "svelte" : T["__runtime"] extends "vue" ? "vue" : never;
type ElementEsque<TRuntime extends AnyRuntime> = TRuntime extends "react" ? ReactNode : TRuntime extends "solid" ? JSX.Element : ReturnType<RenderFunction>;
type CSSPropertiesEsque<TRuntime extends AnyRuntime> = TRuntime extends "react" ? CSSProperties : TRuntime extends "solid" ? JSX.CSSProperties : TRuntime extends "svelte" ? string : TRuntime extends "vue" ? StyleValue : never;
type StyleField<CallbackArg extends MinCallbackArg, TRuntime extends AnyRuntime = inferRuntime<CallbackArg>> = string | CSSPropertiesEsque<TRuntime> | ((arg: Omit<CallbackArg, "__runtime">) => string | CSSPropertiesEsque<TRuntime>);
type ContentField<CallbackArg extends MinCallbackArg, TRuntime extends AnyRuntime = inferRuntime<CallbackArg>> = ElementEsque<TRuntime> | ((arg: Omit<CallbackArg, "__runtime">) => ElementEsque<TRuntime>);
declare const styleFieldToClassName: <T extends MinCallbackArg>(styleField: StyleField<T> | undefined, args: T) => string;
declare const styleFieldToCssObject: <T extends MinCallbackArg>(styleField: StyleField<T> | undefined, args: T) => (CSSPropertiesEsque<inferRuntime<T>> & null) | {};
declare const contentFieldToContent: <T extends MinCallbackArg>(contentField: ContentField<T> | undefined, arg: T) => ElementEsque<inferRuntime<T>> | null | undefined;

declare const signPayload: (payload: string, secret: string) => Promise<string>;
declare const verifySignature: (payload: string, signature: string | null, secret: string) => Promise<boolean>;

export { type ACL, ACLSchema, ALLOWED_FILE_TYPES, type AllowedFileType, type ContentDisposition, ContentDispositionSchema, type ContentField, type Either, type EndpointMetadata, type ErrorMessage, type ExpandedRouteConfig, type ExtendObjectIf, FILESIZE_UNITS, FetchContext, type FetchContextService, FetchError, type FetchEsque, type FileRouterInputConfig, type FileRouterInputKey, type FileSize, type FileSizeUnit, INTERNAL_DO_NOT_USE__fatalClientError, INTERNAL_doFormatting, InvalidFileSizeError, InvalidFileTypeError, InvalidRouteConfigError, InvalidURLError, type Json, type JsonArray, type JsonObject, type JsonValue, type MaybePromise, type MaybeUrl, type Overwrite, type RequestInitEsque, type ResponseEsque, RetryError, type SerializedUploadThingError, type Simplify, type SizeUnit, type StyleField, type Time, type TimeLong, type TimeShort, UnknownFileTypeError, UploadThingError, type WithRequired, allowedContentTextLabelGenerator, asArray, bytesToFileSize, capitalizeStart, contentDisposition, contentFieldToContent, exponentialBackoff, fetchEff, fetchEffJson, fileSizeToBytes, fillInputRouteConfig, filterObjectValues, generateClientDropzoneAccept, generateMimeTypes, generatePermittedFileTypes, generateUploadThingURL, getDefaultSizeForType, getFilesFromClipboardEvent, getFullApiUrl, getStatusCodeFromError, getTypeFromFileName, isObject, isRouteArray, objectKeys, parseRequestJson, resolveMaybeUrlArg, safeParseJSON, semverLite, signPayload, styleFieldToClassName, styleFieldToCssObject, verifySignature };
