import * as S from '@effect/schema/Schema';
import * as Effect from 'effect/Effect';
import { process } from 'std-env';
import { lookup } from '@uploadthing/mime-types';
import { TaggedError } from 'effect/Data';
import * as Context from 'effect/Context';
import * as Duration from 'effect/Duration';
import { pipe } from 'effect/Function';
import * as Schedule from 'effect/Schedule';

const ContentDispositionSchema = S.Literal("inline", "attachment");
const ACLSchema = S.Literal("public-read", "private");

class InvalidRouteConfigError extends TaggedError("InvalidRouteConfig") {
    constructor(type, field){
        const reason = field ? `Expected route config to have a ${field} for key ${type} but none was found.` : `Encountered an invalid route config during backfilling. ${type} was not found.`;
        super({
            reason
        });
    }
}
class UnknownFileTypeError extends TaggedError("UnknownFileType") {
    constructor(fileName){
        const reason = `Could not determine type for ${fileName}`;
        super({
            reason
        });
    }
}
class InvalidFileTypeError extends TaggedError("InvalidFileType") {
    constructor(fileType, fileName){
        const reason = `File type ${fileType} not allowed for ${fileName}`;
        super({
            reason
        });
    }
}
class InvalidFileSizeError extends TaggedError("InvalidFileSize") {
    constructor(fileSize){
        const reason = `Invalid file size: ${fileSize}`;
        super({
            reason
        });
    }
}
class InvalidURLError extends TaggedError("InvalidURL") {
    constructor(attemptedUrl){
        super({
            reason: `Failed to parse '${attemptedUrl}' as a URL.`
        });
    }
}
class RetryError extends TaggedError("RetryError") {
}
class FetchError extends TaggedError("FetchError") {
}

function isRouteArray(routeConfig) {
    return Array.isArray(routeConfig);
}
function getDefaultSizeForType(fileType) {
    if (fileType === "image") return "4MB";
    if (fileType === "video") return "16MB";
    if (fileType === "audio") return "8MB";
    if (fileType === "blob") return "8MB";
    if (fileType === "pdf") return "4MB";
    if (fileType === "text") return "64KB";
    return "4MB";
}
/**
 * This function takes in the user's input and "upscales" it to a full config
 *
 * Example:
 * ```ts
 * ["image"] => { image: { maxFileSize: "4MB", limit: 1 } }
 * ```
 */ const fillInputRouteConfig = (routeConfig)=>{
    // If array, apply defaults
    if (isRouteArray(routeConfig)) {
        return Effect.succeed(routeConfig.reduce((acc, fileType)=>{
            acc[fileType] = {
                // Apply defaults
                maxFileSize: getDefaultSizeForType(fileType),
                maxFileCount: 1,
                minFileCount: 1,
                contentDisposition: "inline"
            };
            return acc;
        }, {}));
    }
    // Backfill defaults onto config
    const newConfig = {};
    for (const key of objectKeys(routeConfig)){
        const value = routeConfig[key];
        if (!value) return Effect.fail(new InvalidRouteConfigError(key));
        const defaultValues = {
            maxFileSize: getDefaultSizeForType(key),
            maxFileCount: 1,
            minFileCount: 1,
            contentDisposition: "inline"
        };
        newConfig[key] = {
            ...defaultValues,
            ...value
        };
    }
    return Effect.succeed(newConfig);
};
const getTypeFromFileName = (fileName, allowedTypes)=>{
    const mimeType = lookup(fileName);
    if (!mimeType) {
        if (allowedTypes.includes("blob")) return Effect.succeed("blob");
        return Effect.fail(new UnknownFileTypeError(fileName));
    }
    // If the user has specified a specific mime type, use that
    if (allowedTypes.some((type)=>type.includes("/"))) {
        if (allowedTypes.includes(mimeType)) {
            return Effect.succeed(mimeType);
        }
    }
    // Otherwise, we have a "magic" type eg. "image" or "video"
    const type = mimeType.toLowerCase() === "application/pdf" ? "pdf" : mimeType.split("/")[0];
    if (!allowedTypes.includes(type)) {
        // Blob is a catch-all for any file type not explicitly supported
        if (allowedTypes.includes("blob")) {
            return Effect.succeed("blob");
        } else {
            return Effect.fail(new InvalidFileTypeError(type, fileName));
        }
    }
    return Effect.succeed(type);
};
function generateUploadThingURL(path) {
    let host = "https://uploadthing.com";
    if (process.env.CUSTOM_INFRA_URL) {
        host = process.env.CUSTOM_INFRA_URL;
    }
    return `${host}${path}`;
}
const FILESIZE_UNITS = [
    "B",
    "KB",
    "MB",
    "GB"
];
const fileSizeToBytes = (fileSize)=>{
    const regex = new RegExp(`^(\\d+)(\\.\\d+)?\\s*(${FILESIZE_UNITS.join("|")})$`, "i");
    // make sure the string is in the format of 123KB
    const match = fileSize.match(regex);
    if (!match) {
        return Effect.fail(new InvalidFileSizeError(fileSize));
    }
    const sizeValue = parseFloat(match[1]);
    const sizeUnit = match[3].toUpperCase();
    const bytes = sizeValue * Math.pow(1024, FILESIZE_UNITS.indexOf(sizeUnit));
    return Effect.succeed(Math.floor(bytes));
};
const bytesToFileSize = (bytes)=>{
    if (bytes === 0 || bytes === -1) {
        return "0B";
    }
    const i = Math.floor(Math.log(bytes) / Math.log(1000));
    return `${(bytes / Math.pow(1000, i)).toFixed(2)}${FILESIZE_UNITS[i]}`;
};
async function safeParseJSON(input) {
    if (typeof input === "string") {
        try {
            return JSON.parse(input);
        } catch (err) {
            console.error(`Error parsing JSON, got '${input}'`);
            return new Error(`Error parsing JSON, got '${input}'`);
        }
    }
    const text = await input.text();
    try {
        return JSON.parse(text ?? "null");
    } catch (err) {
        console.error(`Error parsing JSON, got '${text}'`);
        return new Error(`Error parsing JSON, got '${text}'`);
    }
}
/** typesafe Object.keys */ function objectKeys(obj) {
    return Object.keys(obj);
}
/** checks if obj is a valid, non-null object */ function isObject(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function asArray(val) {
    return Array.isArray(val) ? val : [
        val
    ];
}
/**
 * Filters an object's values based on a predicate
 * @example
 * filterObjectValues({ a: "a", b: null }, (v): v is string => v != null)
 * // ^? Record<string, string> { a: "a" }
 */ const filterObjectValues = (obj, predicate)=>{
    return Object.fromEntries(Object.entries(obj).filter(([_, v])=>predicate(v)));
};
/** construct content-disposition header */ function contentDisposition(contentDisposition, fileName) {
    return [
        contentDisposition,
        `filename="${encodeURI(fileName)}"`,
        `filename*=UTF-8''${encodeURI(fileName)}`
    ].join("; ");
}
function semverLite(required, toCheck) {
    // Pull out numbers from strings like `6.0.0`, `^6.4`, `~6.4.0`
    const semverRegex = /(\d+)\.?(\d+)?\.?(\d+)?/;
    const requiredMatch = required.match(semverRegex);
    if (!requiredMatch?.[0]) {
        throw new Error(`Invalid semver requirement: ${required}`);
    }
    const toCheckMatch = toCheck.match(semverRegex);
    if (!toCheckMatch?.[0]) {
        throw new Error(`Invalid semver to check: ${toCheck}`);
    }
    const [_1, rMajor, rMinor, rPatch] = requiredMatch;
    const [_2, cMajor, cMinor, cPatch] = toCheckMatch;
    if (required.startsWith("^")) {
        // Major must be equal, minor must be greater or equal
        if (rMajor !== cMajor) return false;
        if (rMinor > cMinor) return false;
        return true;
    }
    if (required.startsWith("~")) {
        // Major must be equal, minor must be equal
        if (rMajor !== cMajor) return false;
        if (rMinor !== cMinor) return false;
        return true;
    }
    // Exact match
    return rMajor === cMajor && rMinor === cMinor && rPatch === cPatch;
}
const getFullApiUrl = (maybeUrl)=>Effect.gen(function*() {
        const base = (()=>{
            if (typeof window !== "undefined") return window.location.origin;
            if (process.env?.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;
            return "http://localhost:3000";
        })();
        const url = yield* Effect.try({
            try: ()=>new URL(maybeUrl ?? "/api/uploadthing", base),
            catch: ()=>new InvalidURLError(maybeUrl ?? "/api/uploadthing")
        });
        if (url.pathname === "/") {
            url.pathname = "/api/uploadthing";
        }
        return url;
    });
/*
 * Returns a full URL to the dev's uploadthing endpoint
 * Can take either an origin, or a pathname, or a full URL
 * and will return the "closest" url matching the default
 * `<VERCEL_URL || localhost>/api/uploadthing`
 */ const resolveMaybeUrlArg = (maybeUrl)=>{
    return maybeUrl instanceof URL ? maybeUrl : Effect.runSync(getFullApiUrl(maybeUrl));
};

const ALLOWED_FILE_TYPES = [
    "image",
    "video",
    "audio",
    "pdf",
    "text",
    "blob"
];

const ERROR_CODES = {
    // Generic
    BAD_REQUEST: 400,
    NOT_FOUND: 404,
    FORBIDDEN: 403,
    INTERNAL_SERVER_ERROR: 500,
    INTERNAL_CLIENT_ERROR: 500,
    // S3 specific
    TOO_LARGE: 413,
    TOO_SMALL: 400,
    TOO_MANY_FILES: 400,
    KEY_TOO_LONG: 400,
    // UploadThing specific
    URL_GENERATION_FAILED: 500,
    UPLOAD_FAILED: 500,
    MISSING_ENV: 500,
    FILE_LIMIT_EXCEEDED: 500
};
function messageFromUnknown(cause, fallback) {
    if (typeof cause === "string") {
        return cause;
    }
    if (cause instanceof Error) {
        return cause.message;
    }
    if (cause && typeof cause === "object" && "message" in cause && typeof cause.message === "string") {
        return cause.message;
    }
    return fallback ?? "An unknown error occurred";
}
class UploadThingError extends TaggedError("UploadThingError") {
    constructor(initOpts){
        const opts = typeof initOpts === "string" ? {
            code: "INTERNAL_SERVER_ERROR",
            message: initOpts
        } : initOpts;
        const message = opts.message ?? messageFromUnknown(opts.cause, opts.code);
        super({
            message
        });
        this.code = opts.code;
        this.data = opts.data;
        if (opts.cause instanceof Error) {
            this.cause = opts.cause;
        } else if (isObject(opts.cause) && typeof opts.cause.status === "number" && typeof opts.cause.statusText === "string") {
            this.cause = new Error(`Response ${opts.cause.status} ${opts.cause.statusText}`);
        } else if (typeof opts.cause === "string") {
            this.cause = new Error(opts.cause);
        } else {
            this.cause = opts.cause;
        }
    }
    static toObject(error) {
        return {
            code: error.code,
            message: error.message,
            data: error.data
        };
    }
    static serialize(error) {
        return JSON.stringify(UploadThingError.toObject(error));
    }
}
function getStatusCodeFromError(error) {
    return ERROR_CODES[error.code] ?? 500;
}
const INTERNAL_DO_NOT_USE__fatalClientError = (e)=>new UploadThingError({
        code: "INTERNAL_CLIENT_ERROR",
        message: "Something went wrong. Please report this to UploadThing.",
        cause: e
    });

class FetchContext extends Context.Tag("uploadthing/FetchContext")() {
}
// Temporary Effect wrappers below.
// TODO should be refactored with much love
// TODO handle error properly
const fetchEff = (input, init)=>FetchContext.pipe(Effect.andThen(({ fetch, baseHeaders })=>Effect.tryPromise({
            try: ()=>fetch(input, {
                    ...init,
                    headers: {
                        ...filterObjectValues(baseHeaders, (v)=>v != null),
                        ...init?.headers
                    }
                }),
            catch: (error)=>new FetchError({
                    error,
                    input
                })
        })), Effect.withSpan("fetch", {
        attributes: {
            input: JSON.stringify(input)
        }
    }));
const fetchEffJson = (input, /** Schema to be used if the response returned a 2xx  */ schema, init)=>{
    const requestUrl = typeof input === "string" ? input : input instanceof URL ? input.toString() : input.url;
    return fetchEff(input, init).pipe(Effect.andThen((res)=>Effect.tryPromise({
            try: async ()=>{
                const json = await res.json();
                return {
                    ok: res.ok,
                    json,
                    status: res.status
                };
            },
            catch: (error)=>new FetchError({
                    error,
                    input
                })
        })), Effect.andThen(({ ok, json, status })=>ok ? Effect.succeed(json) : Effect.fail(new FetchError({
            error: `Request to ${requestUrl} failed with status ${status}`,
            data: json,
            input
        }))), Effect.andThen(S.decode(schema)), Effect.withSpan("fetchJson", {
        attributes: {
            input: JSON.stringify(input)
        }
    }));
};
const parseRequestJson = (reqOrRes, schema)=>Effect.tryPromise({
        try: ()=>reqOrRes.json(),
        catch: (error)=>new FetchError({
                error,
                input: "url" in reqOrRes ? reqOrRes.url : `Response ${reqOrRes.status} - ${reqOrRes.statusText}`
            })
    }).pipe(Effect.andThen(S.decode(schema)));
/**
 * Schedule that retries with exponential backoff, up to 1 minute.
 * 10ms * 4^n, where n is the number of retries.
 */ const exponentialBackoff = pipe(Schedule.exponential(Duration.millis(10), 4), Schedule.andThenEither(Schedule.spaced(Duration.seconds(1))), Schedule.compose(Schedule.elapsed), Schedule.whileOutput(Duration.lessThanOrEqualTo(Duration.minutes(1))));

const generateMimeTypes = (fileTypes)=>{
    const accepted = fileTypes.map((type)=>{
        if (type === "blob") return "blob";
        if (type === "pdf") return "application/pdf";
        if (type.includes("/")) return type;
        else return `${type}/*`;
    });
    if (accepted.includes("blob")) {
        return [];
    }
    return accepted;
};
const generateClientDropzoneAccept = (fileTypes)=>{
    const mimeTypes = generateMimeTypes(fileTypes);
    return Object.fromEntries(mimeTypes.map((type)=>[
            type,
            []
        ]));
};
function getFilesFromClipboardEvent(event) {
    const dataTransferItems = event.clipboardData?.items;
    if (!dataTransferItems) return;
    const files = Array.from(dataTransferItems).reduce((acc, curr)=>{
        const f = curr.getAsFile();
        return f ? [
            ...acc,
            f
        ] : acc;
    }, []);
    return files;
}
/**
 * Shared helpers for our premade components that's reusable by multiple frameworks
 */ const generatePermittedFileTypes = (config)=>{
    const fileTypes = config ? objectKeys(config) : [];
    const maxFileCount = config ? Object.values(config).map((v)=>v.maxFileCount) : [];
    return {
        fileTypes,
        multiple: maxFileCount.some((v)=>v && v > 1)
    };
};
const capitalizeStart = (str)=>{
    return str.charAt(0).toUpperCase() + str.slice(1);
};
const INTERNAL_doFormatting = (config)=>{
    if (!config) return "";
    const allowedTypes = objectKeys(config);
    const formattedTypes = allowedTypes.map((f)=>f === "blob" ? "file" : f);
    // Format multi-type uploader label as "Supports videos, images and files";
    if (formattedTypes.length > 1) {
        const lastType = formattedTypes.pop();
        return `${formattedTypes.join("s, ")} and ${lastType}s`;
    }
    // Single type uploader label
    const key = allowedTypes[0];
    const formattedKey = formattedTypes[0];
    const { maxFileSize, maxFileCount, minFileCount } = config[key];
    if (maxFileCount && maxFileCount > 1) {
        if (minFileCount > 1) {
            return `${minFileCount} - ${maxFileCount} ${formattedKey}s up to ${maxFileSize}`;
        } else {
            return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;
        }
    } else {
        return `${formattedKey} (${maxFileSize})`;
    }
};
const allowedContentTextLabelGenerator = (config)=>{
    return capitalizeStart(INTERNAL_doFormatting(config));
};
const styleFieldToClassName = (styleField, args)=>{
    if (typeof styleField === "string") return styleField;
    if (typeof styleField === "function") {
        const result = styleField(args);
        if (typeof result === "string") return result;
    }
    return "";
};
const styleFieldToCssObject = (styleField, args)=>{
    if (typeof styleField === "object") return styleField;
    if (typeof styleField === "function") {
        const result = styleField(args);
        if (typeof result === "object") return result;
    }
    return {};
};
const contentFieldToContent = (contentField, arg)=>{
    if (!contentField) return null;
    if (typeof contentField !== "function") return contentField;
    if (typeof contentField === "function") {
        const result = contentField(arg);
        return result;
    }
};

const signaturePrefix = "hmac-sha256=";
const algorithm = {
    name: "HMAC",
    hash: "SHA-256"
};
const signPayload = async (payload, secret)=>{
    const encoder = new TextEncoder();
    const signingKey = await crypto.subtle.importKey("raw", encoder.encode(secret), algorithm, false, [
        "sign"
    ]);
    const signature = await crypto.subtle.sign(algorithm, signingKey, encoder.encode(payload)).then((sig)=>Buffer.from(sig).toString("hex"));
    return `${signaturePrefix}${signature}`;
};
const verifySignature = async (payload, signature, secret)=>{
    const sig = signature?.slice(signaturePrefix.length);
    if (!sig) return false;
    const encoder = new TextEncoder();
    const signingKey = await crypto.subtle.importKey("raw", encoder.encode(secret), algorithm, false, [
        "verify"
    ]);
    return await crypto.subtle.verify(algorithm, signingKey, Uint8Array.from(Buffer.from(sig, "hex")), encoder.encode(payload));
};

export { ACLSchema, ALLOWED_FILE_TYPES, ContentDispositionSchema, FILESIZE_UNITS, FetchContext, FetchError, INTERNAL_DO_NOT_USE__fatalClientError, INTERNAL_doFormatting, InvalidFileSizeError, InvalidFileTypeError, InvalidRouteConfigError, InvalidURLError, RetryError, UnknownFileTypeError, UploadThingError, allowedContentTextLabelGenerator, asArray, bytesToFileSize, capitalizeStart, contentDisposition, contentFieldToContent, exponentialBackoff, fetchEff, fetchEffJson, fileSizeToBytes, fillInputRouteConfig, filterObjectValues, generateClientDropzoneAccept, generateMimeTypes, generatePermittedFileTypes, generateUploadThingURL, getDefaultSizeForType, getFilesFromClipboardEvent, getFullApiUrl, getStatusCodeFromError, getTypeFromFileName, isObject, isRouteArray, objectKeys, parseRequestJson, resolveMaybeUrlArg, safeParseJSON, semverLite, signPayload, styleFieldToClassName, styleFieldToCssObject, verifySignature };
