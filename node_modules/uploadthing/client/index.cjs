Object.defineProperty(exports, '__esModule', { value: true });

var S = require('@effect/schema/Schema');
var Effect = require('effect/Effect');
var shared = require('@uploadthing/shared');
var Cause = require('effect/Cause');
var stdEnv = require('std-env');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return n;
}

var S__namespace = /*#__PURE__*/_interopNamespace(S);
var Effect__namespace = /*#__PURE__*/_interopNamespace(Effect);
var Cause__namespace = /*#__PURE__*/_interopNamespace(Cause);

var version$1 = "6.10.1";

const uploadMultipartWithProgress = (file, presigned, opts)=>Effect__namespace.gen(function*() {
        let uploadedBytes = 0;
        const etags = yield* Effect__namespace.forEach(presigned.urls, (url, index)=>{
            const offset = presigned.chunkSize * index;
            const end = Math.min(offset + presigned.chunkSize, file.size);
            const chunk = file.slice(offset, end);
            return uploadPart({
                url,
                chunk: chunk,
                contentDisposition: presigned.contentDisposition,
                fileType: file.type,
                fileName: file.name,
                onProgress: (delta)=>{
                    uploadedBytes += delta;
                    const percent = uploadedBytes / file.size * 100;
                    opts.onUploadProgress?.({
                        file: file.name,
                        progress: percent
                    });
                }
            }).pipe(Effect__namespace.andThen((tag)=>({
                    tag,
                    partNumber: index + 1
                })), Effect__namespace.retry({
                while: (error)=>error instanceof shared.RetryError,
                times: stdEnv.isTest ? 3 : 10,
                schedule: shared.exponentialBackoff
            }));
        }, {
            concurrency: "inherit"
        }).pipe(Effect__namespace.tapErrorCause((error)=>opts.reportEventToUT("failure", {
                fileKey: presigned.key,
                uploadId: presigned.uploadId,
                fileName: file.name,
                storageProviderError: Cause__namespace.pretty(error).toString()
            }, S__namespace.Null)));
        // Tell the server that the upload is complete
        yield* opts.reportEventToUT("multipart-complete", {
            uploadId: presigned.uploadId,
            fileKey: presigned.key,
            etags
        }, S__namespace.Null);
    });
const uploadPart = (opts)=>Effect__namespace.async((resume)=>{
        const xhr = new XMLHttpRequest();
        xhr.open("PUT", opts.url, true);
        xhr.setRequestHeader("Content-Type", opts.fileType);
        xhr.setRequestHeader("Content-Disposition", shared.contentDisposition(opts.contentDisposition, opts.fileName));
        xhr.addEventListener("load", ()=>{
            const etag = xhr.getResponseHeader("Etag");
            if (xhr.status >= 200 && xhr.status <= 299 && etag) {
                return resume(Effect__namespace.succeed(etag));
            }
            return resume(Effect__namespace.fail(new shared.RetryError()));
        });
        xhr.addEventListener("error", ()=>resume(Effect__namespace.fail(new shared.RetryError())));
        let lastProgress = 0;
        xhr.upload.addEventListener("progress", (e)=>{
            const delta = e.loaded - lastProgress;
            lastProgress += delta;
            opts.onProgress(delta);
        });
        xhr.send(opts.chunk);
    });

const uploadPresignedPostWithProgress = (file, presigned, opts)=>Effect__namespace.async((resume)=>{
        const xhr = new XMLHttpRequest();
        xhr.open("POST", presigned.url);
        xhr.setRequestHeader("Accept", "application/xml");
        xhr.upload.addEventListener("progress", ({ loaded, total })=>{
            opts.onUploadProgress?.({
                file: file.name,
                progress: loaded / total * 100
            });
        });
        xhr.addEventListener("load", ()=>resume(xhr.status >= 200 && xhr.status < 300 ? Effect__namespace.succeed(null) : opts.reportEventToUT("failure", {
                fileKey: presigned.key,
                uploadId: null,
                fileName: file.name,
                storageProviderError: xhr.responseText
            }, S__namespace.Null)));
        xhr.addEventListener("error", ()=>resume(opts.reportEventToUT("failure", {
                fileKey: presigned.key,
                uploadId: null,
                fileName: file.name
            }, S__namespace.Null)));
        const formData = new FormData();
        Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));
        formData.append("file", file); // File data **MUST GO LAST**
        xhr.send(formData);
    });

/**
 * =============================================================================
 * ======================== File Type Hierarchy ===============================
 * =============================================================================
 */ const FileUploadDataSchema = S__namespace.Struct({
    name: S__namespace.String,
    size: S__namespace.Number,
    type: S__namespace.String
});
const FileUploadDataWithCustomIdSchema = S__namespace.extend(FileUploadDataSchema, S__namespace.Struct({
    customId: S__namespace.NullOr(S__namespace.String)
}));
S__namespace.extend(FileUploadDataWithCustomIdSchema, S__namespace.Struct({
    key: S__namespace.String,
    url: S__namespace.String
}));
/**
 * =============================================================================
 * ======================== Server Response Schemas ============================
 * =============================================================================
 */ const PresignedBaseSchema = S__namespace.Struct({
    key: S__namespace.String,
    fileName: S__namespace.String,
    fileType: S__namespace.String,
    fileUrl: S__namespace.String,
    pollingJwt: S__namespace.String,
    pollingUrl: S__namespace.String,
    contentDisposition: shared.ContentDispositionSchema,
    customId: S__namespace.NullOr(S__namespace.String)
});
const MPUResponseSchema = S__namespace.extend(PresignedBaseSchema, S__namespace.Struct({
    urls: S__namespace.Array(S__namespace.String),
    uploadId: S__namespace.String,
    chunkSize: S__namespace.Number,
    chunkCount: S__namespace.Number
}));
const PSPResponseSchema = S__namespace.extend(PresignedBaseSchema, S__namespace.Struct({
    url: S__namespace.String,
    fields: S__namespace.Record(S__namespace.String, S__namespace.String)
}));
const PresignedURLResponseSchema = S__namespace.Array(S__namespace.Union(PSPResponseSchema, MPUResponseSchema));
S__namespace.Struct({
    status: S__namespace.String,
    fileData: S__namespace.optional(S__namespace.Struct({
        fileKey: S__namespace.NullOr(S__namespace.String),
        fileName: S__namespace.String,
        fileSize: S__namespace.Number,
        fileType: S__namespace.String,
        metadata: S__namespace.NullOr(S__namespace.String),
        customId: S__namespace.NullOr(S__namespace.String),
        callbackUrl: S__namespace.optional(S__namespace.String),
        callbackSlug: S__namespace.optional(S__namespace.String)
    }))
});
S__namespace.Struct({
    success: S__namespace.Boolean,
    message: S__namespace.optional(S__namespace.String)
});
S__namespace.Struct({
    status: S__namespace.String
});
/**
 * =============================================================================
 * ======================== Client Action Payloads ============================
 * =============================================================================
 */ S__namespace.Struct({
    files: S__namespace.Array(FileUploadDataSchema),
    input: S__namespace.Unknown
});
S__namespace.Struct({
    fileKey: S__namespace.String,
    uploadId: S__namespace.NullOr(S__namespace.String),
    storageProviderError: S__namespace.optional(S__namespace.String),
    fileName: S__namespace.String
});
S__namespace.Struct({
    fileKey: S__namespace.String,
    uploadId: S__namespace.String,
    etags: S__namespace.Array(S__namespace.Struct({
        tag: S__namespace.String,
        partNumber: S__namespace.Number
    }))
});

const maybeParseResponseXML = (maybeXml)=>{
    const codeMatch = maybeXml.match(/<Code>(.*?)<\/Code>/s);
    const messageMatch = maybeXml.match(/<Message>(.*?)<\/Message>/s);
    const code = codeMatch?.[1];
    const message = messageMatch?.[1];
    if (!code || !message) return null;
    return {
        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,
        message
    };
};
/**
 * Map S3 error codes to UploadThing error codes
 *
 * This is a subset of the S3 error codes, based on what seemed most likely to
 * occur in uploadthing. For a full list of S3 error codes, see:
 * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html
 */ const DEFAULT_ERROR_CODE = "UPLOAD_FAILED";
const s3CodeToUploadThingCode = {
    AccessDenied: "FORBIDDEN",
    EntityTooSmall: "TOO_SMALL",
    EntityTooLarge: "TOO_LARGE",
    ExpiredToken: "FORBIDDEN",
    IncorrectNumberOfFilesInPostRequest: "TOO_MANY_FILES",
    InternalError: "INTERNAL_SERVER_ERROR",
    KeyTooLongError: "KEY_TOO_LONG",
    MaxMessageLengthExceeded: "TOO_LARGE"
};

const createAPIRequestUrl = (config)=>{
    const url = new URL(config.url);
    const queryParams = new URLSearchParams(url.search);
    queryParams.set("actionType", config.actionType);
    queryParams.set("slug", config.slug);
    url.search = queryParams.toString();
    return url;
};
/**
 * Creates a "client" for reporting events to the UploadThing server via the user's API endpoint.
 * Events are handled in "./handler.ts starting at L112"
 */ const createUTReporter = (cfg)=>(type, payload, responseSchema)=>Effect__namespace.gen(function*() {
            const url = createAPIRequestUrl({
                url: cfg.url,
                slug: cfg.endpoint,
                actionType: type
            });
            let headers = typeof cfg.headers === "function" ? cfg.headers() : cfg.headers;
            if (headers instanceof Promise) {
                headers = yield* Effect__namespace.promise(()=>headers);
            }
            const response = yield* shared.fetchEffJson(url, responseSchema, {
                method: "POST",
                body: JSON.stringify(payload),
                headers: {
                    "Content-Type": "application/json",
                    "x-uploadthing-package": cfg.package,
                    "x-uploadthing-version": version$1,
                    ...headers
                }
            }).pipe(Effect__namespace.catchTag("FetchError", (e)=>Effect__namespace.fail(new shared.UploadThingError({
                    code: "INTERNAL_CLIENT_ERROR",
                    message: `Failed to report event "${type}" to UploadThing server`,
                    cause: e
                }))), Effect__namespace.catchTag("ParseError", (e)=>Effect__namespace.fail(new shared.UploadThingError({
                    code: "INTERNAL_CLIENT_ERROR",
                    message: "Failed to parse response from UploadThing server",
                    cause: e
                }))));
            switch(type){
                case "failure":
                    {
                        // why isn't this narrowed automatically?
                        const p = payload;
                        const parsed = maybeParseResponseXML(p.storageProviderError ?? "");
                        if (parsed?.message) {
                            return yield* new shared.UploadThingError({
                                code: parsed.code,
                                message: parsed.message
                            });
                        } else {
                            return yield* new shared.UploadThingError({
                                code: "UPLOAD_FAILED",
                                message: `Failed to upload file ${p.fileName} to S3`,
                                cause: p.storageProviderError
                            });
                        }
                    }
            }
            return response;
        });

const version = version$1;
const uploadFilesInternal = (endpoint, opts)=>Effect__namespace.gen(function*() {
        const reportEventToUT = createUTReporter({
            endpoint: String(endpoint),
            package: opts.package,
            url: shared.resolveMaybeUrlArg(opts.url),
            headers: opts.headers
        });
        const presigneds = yield* reportEventToUT("upload", {
            input: "input" in opts ? opts.input : null,
            files: opts.files.map((f)=>({
                    name: f.name,
                    size: f.size,
                    type: f.type
                }))
        }, PresignedURLResponseSchema);
        return yield* Effect__namespace.forEach(presigneds, (presigned)=>uploadFile(String(endpoint), {
                ...opts,
                reportEventToUT
            }, presigned), {
            concurrency: 6
        });
    });
const genUploader = (initOpts)=>{
    return (endpoint, opts)=>uploadFilesInternal(endpoint, {
            ...opts,
            url: shared.resolveMaybeUrlArg(initOpts?.url),
            package: initOpts.package,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            input: opts.input
        }).pipe(Effect__namespace.provideService(shared.FetchContext, {
            fetch: globalThis.fetch.bind(globalThis),
            baseHeaders: {
                "x-uploadthing-version": version$1,
                "x-uploadthing-api-key": undefined,
                "x-uploadthing-fe-package": initOpts.package,
                "x-uploadthing-be-adapter": undefined
            }
        }), Effect__namespace.runPromise);
};
const uploadFile = (slug, opts, presigned)=>Effect__namespace.gen(function*() {
        const file = opts.files.find((f)=>f.name === presigned.fileName);
        if (!file) {
            console.error("No file found for presigned URL", presigned);
            return yield* new shared.UploadThingError({
                code: "NOT_FOUND",
                message: "No file found for presigned URL",
                cause: `Expected file with name ${presigned.fileName} but got '${opts.files.join(",")}'`
            });
        }
        opts.onUploadBegin?.({
            file: file.name
        });
        if ("urls" in presigned) {
            yield* uploadMultipartWithProgress(file, presigned, opts);
        } else {
            yield* uploadPresignedPostWithProgress(file, presigned, opts);
        }
        const PollingResponse = S__namespace.Union(S__namespace.Struct({
            status: S__namespace.Literal("done"),
            callbackData: S__namespace.Any
        }), S__namespace.Struct({
            status: S__namespace.Literal("still waiting")
        }));
        let serverData = null;
        if (!opts.skipPolling) {
            serverData = yield* shared.fetchEffJson(presigned.pollingUrl, PollingResponse, {
                headers: {
                    authorization: presigned.pollingJwt
                }
            }).pipe(Effect__namespace.andThen((res)=>res.status === "done" ? Effect__namespace.succeed(res.callbackData) : Effect__namespace.fail(new shared.RetryError())), Effect__namespace.retry({
                while: (res)=>res instanceof shared.RetryError,
                schedule: shared.exponentialBackoff
            }));
        }
        return {
            name: file.name,
            size: file.size,
            key: presigned.key,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            serverData: serverData,
            url: "https://utfs.io/f/" + presigned.key,
            customId: presigned.customId,
            type: file.type
        };
    });

Object.defineProperty(exports, "generateClientDropzoneAccept", {
  enumerable: true,
  get: function () { return shared.generateClientDropzoneAccept; }
});
Object.defineProperty(exports, "generateMimeTypes", {
  enumerable: true,
  get: function () { return shared.generateMimeTypes; }
});
Object.defineProperty(exports, "generatePermittedFileTypes", {
  enumerable: true,
  get: function () { return shared.generatePermittedFileTypes; }
});
exports.genUploader = genUploader;
exports.version = version;
